## Сборка программы
Перед сборкой необходимо подгрузить все подмодули git, создать директорию сборки,
сгенерировать файлы сборки и запустить сборку. Команды для сборки могут немного отличаться из за разных компиляторов. Ниже приведены примеры, как собиралась программа для тестов на Linux и Windows.
Пример Linux:
```bash
git submodule update --init --recursive # подгружаем сабмодули
mkdir build && cd build # создаем директорию сборки и переходим в нее
cmake .. # генерируем файлы сборки
cmake --build . # запускаем сборку
```
Пример Windows:
```bash
git submodule update --init --recursive # подгружаем сабмодули
mkdir build && cd build # создаем директорию сборки и переходим в нее
cmake .. -G "MinGW Makefiles" # генерируем файлы сборки
cmake --build . # запускаем сборку
```
## Запуск программы
Запускать программу необходимо из корневой директории проекта, иначе не будет найдет файл конфигурации `settings.json`. Вот пример запуска программы после сборки:
```bash
cd .. # переходим в корневую директорию проекта
build/bin/yuki-voice-assistant # запуск бинарника из корневой директории
```
## Примечание для Linux
На линукс для открытия вебсайтов используется `xdg-open`, если данная утилита отсутствует на устройстве или не работает корректно, то вебсайты могут не открываться. Для взаимодействия с медиа используется `playerctl`, аналогично с `xdg-open`, данная утилита должна быть установлена на устройстве и корректно работать.
## Архитектура проекта
`RequestType` - перечисление поддерживаемых типов запросов:
	0. SCENARIO - сценарий позволяет использовать несколько запросов с установленными аргументами одной командой. Например команда `включи музыку` может открыть медиаплеер(например spotify) и переключить состояние медиа(TOGGLE_MEDIA). Не принимает аргументов, задает значение для `Request::scenario_id`.
	1. OPEN - открывает программу или сайт. В качестве аргумента принимает название программы или сайта, которое записано в `applications.json` или в `websites.json`. При выполнении запроса этого типа сначала будет проверяться точное совпадение аргумента с содержимым списка программ, если точных совпадений среди программ не нашлось, то среди сайтов. Если не найдено точного совпадения, то будет совершен обход по всем известным приложениям, а затем сайтам. В процессе обхода будет оцениваться точность каждого элемента с аргументом запроса, результатом будет выбран наиболее подходящий элемент, совпадение которого с аргументов больше 70%(можно уменьшить или увеличить порог точности, изменив константную переменную `ACCURANCY_PERCENT` в `context-graph.h`).
	2. WEB_SEARCH - поиск в интернете, в качестве аргумента получает поисковой запрос. Неподдерживаемые символы в аргументе кодируются в HEX формат и затем закодированная строка открывается через поисковик google.
	3. SHUTDOWN - выключает компьютер.
	4. STOP - останавливает работу программы. Перед остановкой программа будет ждать завершения обработки всех запросов, которые она не успела обработать и выполнить.
	5. TOGGLE_MEDIA - переключает состояние медиа между `вкл` и `выкл`.
	6. PREVIOUS_MEDIA - включает предыдущее медиа (как правило в медиаплеерах, если трек уже воспроизводится несколько секунд, попытка включить предыдущий трек просто отмотает текущую композицию в начало).
	7. NEXT_MEDIA - включает следующее медиа.
	8. UNKNOWN - неизвестный тип запроса, выполняться такой запрос не будет.
`Request` - структура, представляющая запрос. Хранит в себе `RequestType`, строку с аргументом(если есть) и id сценария.
`Worker` - класс, который получает задачи типа `function<void()>` для выполнения в отдельном потоке и ставит их в очередь на выполнение.
`RecognizeModel` - класс обертка над библиотекой распознавания голоса. В конструкторе принимает `const char*` с путем к модели распознавания. Для подачи аудио на распознавание используется метод `RecognizeAudio`. Использование этого класса позволяет без лишних проблем заменить используемую библиотеку для распознавания речи, изменив содержимое класса, но оставив старый набор аргументов в конструкторе и `RecognizeAudio`, если новая библиотека принимает аудиосемплы типа `int16_t`.
`Node` - структура, представляющая вершину графа контекста. Содержит `RequestType`, признак наличия аргумента(булева переменная) и id сценария. Если `RequestType` имеет тип `UNKNOWN`, то узел считается промежуточным.
`ContextGraph` - граф контекста. Вершины графа - слова, получаемые при разбивании фразы на составляющие. Метод `AddPhrase` позволяет добавить новую фразу в граф, метод `TrainGraph` позволяет заполнить граф данными из csv файла для конструирования графа, подробнее об этом файле можно узнать в месте описания конфигурационных файлов. Метод `AddOftenMistakes` принимает путь к csv файлу с частыми ошибками и позволяет добавить частые ошибки при распознавании речи, которые будут исправляться на правильные слова. Метод `ParsePhrase` принимает команду, проходя по графу определяет тип команды и извлекает аргумент, если он должен быть.
`VoiceAssistantInit` - структура для удобной инициализации `VoiceAssistant`.
`VoiceAssistant` - класс голосового ассистента. В конструкторе принимает `VoiceAssistantInit`, конструирует объект `RecognizeModel` и `ContextGraph` данными, полученными из `VoiceAssistantInit`. Метод `MiniAudioCallback` - callback, вызывающийся из miniaudio, передает полученную информуцию на обработку в `ProcessAudio`, чтобы не останавливать работу miniaudio. Метод `ProcessAudio` проверяет, превышал ли уровень громкости 2000(изменить данный порог можно с помощью переменной `VOL_LIMIT`), если уровень громкости выше этого порога, то записывает речь в аудиобуфер, после этого в отдельном потоке передает его на обработку в `RecognizeModel`, результат распознавания отправляется в `ContextGraph`, затем распознанный запрос выполняется.
## Конфигурационные файлы
Для работы программы необходимы `settings.json` и файл построения графа контекста, без них программа не сможет выполнять свои функции, остальные файлы желательны для полноценной работы программы, но их отсутствие не помешает конструированию всех нужных объектов. Имя и расположение `settings.json` нельзя менять, иначе программа не сможет найти его. Имя и местоположение прочих файлов можно менять, если указать новый путь к файлу в `settings.json`.

`settings.json` - файл настроек программы, хранит пути к остальным конфигурационным файлам. Содержит следующие поля:
	`model` - путь к модели распознавания голоса vosk.
	`ctx_file` - путь к csv файлу для построения ContextGraph.
	`often_mistakes` - путь к csv файлу с частыми ошибками при распознавании речи.
	`websites` - путь к json файлу со списком поддерживаемых веб-сайтов.
	`applications` - путь к json файлу со списком поддерживаемых программ.
	`scenarios` - путь к json файлу со сценариями.
`context_training.csv` - файл для построения графа контекста, содержит 3 столбца: id команды, фраза, наличие(arg) или отсутствие(none) аргумента. Id комманд можно посмотреть в описании `RequestType`. Фраза не должна содержать знаки пунктуации или специальные символы, иначе программа может не распознать корректно тип команды.
`often_mistakes.csv` - файл с частыми ошибками при распознавании речи. Содержит 2 столбца: ошибочно распознанное слово и правильный вариант. При добавлении нового ошибочного слова удостоверьтесь, что оно не является подстрокой какой либо команды или другого ошибочного слова, иначе это приведет к ошибкам определения типа команды. Например, имеется 2 ветки графа контекста, ведущие к разным типам команд и начинающиеся с `включи` и `переключи`, если добавить в файл частых ошибок пару `ключи`->`включи`, то программа не сможет распознать команды по ветке `переключи`, если слово `переключи` будет распознанно неточно(например `переключить`, `переключите`).
`applications.json` - файл со списком поддерживаемых программ. Ключи - названия программ в голосовом ассистенте, по которым будет происходить поиск совпадения с аргументом из запроса на открытие приложений или веб-сайтов. Значения - путь к программе. Важно указывать именно путь к программе, а не команду ее запуска или путь вместе с аргументами, например: на линукс установлен клиент spotify через flatpak и запуск производится через `flatpak run com.spotify.Client`, если указать эту команду в значении для ключа `spotify`, то программа не сможет открыться, т.к. это не путь к файлу. Чтобы в такой ситуации добавить поддержку spotify, нужно создать bash скрипт, запускающий spotify, и указывать путь к этому скрипту, пример такого скрипта:
```bash
#!/bin/bash
flatpak run com.spotify.Client
```
Если директория с бинарником искомой программы находится в системной PATH, то можно просто указать название бинарника.
`websites.json` - файл со списком поддерживаемых веб-сайтов. Ключи - названия сайтов в голосовом ассистенте, по которым будет происходить поиск совпадения с аргументом из запроса на открытие приложений или веб-сайтов. Значения - url сайта.
`scenarios.json` - файл со сценариями. Ключи - команда для выполнения сценария. Значения - массив с запросами. Каждый запрос представляется в виде массива, 1-й элемент которого - тип запроса, 2-й - аргумент, который этот запрос принимает. Если запрос какого то типа не принимает аргумент, то можно оставить массив запроса с 1 элементом, т.к. аргумент не будет проверяться. Например:
```json
{
	"включи музыку": [[1, "spotify"],
							[5]]
}
```
`включи музыку` - команда запуска данного сценария. Сценарий имеет 2 запроса: открыть `spotify` и переключить состояние медиа. Так как переключение состояния медиа не принимает аргумента, то указан только id команды.
## Логирование
Логирование осуществляется в stdout в формате jsonl. Json объект лога имеет 3 поля:
	`timestamp` - временная метка формата `<год>-<месяц>-<число>T<час>:<минута>:<секунда>.<миллисекунда>`.
	`data` - информация о запросе, может иметь следующие поля:
		`type` - тип лога: ошибка, предупреждение, информация и т.д.
		`request_type` - тип запроса.
		`request_arg` - аргумент запроса.
		`scenario_id` - порядковый номер сценария в `scenarios.json`, отсчитывая с 0.
		`exception` - информация об вылетевшем исключении.
		`where` - где произошла ошибки или вылетело исключение.
	`message` - сообщение с дополнительной информацией.
После вывода лога с сообщением `Program loaded successfully` можно пользоваться ассистентом.
Лог с сообщением `Program was completed successfully` свидетельствует об успешном завершении программы без ошибок или исключений.
