## Сборка
Перед сборкой необходимо:
1. инициализироваь и обновить подмодули git.
2. создать директорию сборки.
3. сгенерировать файлы сборки CMake.
4. выполнить сборку.

Команды для сборки могут немного отличаться в зависимости от компилятора и генератора CMake. Ниже приведены примеры команд, использованных при тестировании на Linux и Windows.
#### Linux
```bash
git submodule update --init --recursive # загрузить подмодули
mkdir build && cd build # создать директорию сборки и перейти в нее
cmake .. # сгенерировать файлы сборки
cmake --build . # выполнить сборку
```
#### Windows
```bash
git submodule update --init --recursive # загрузить подмодули
mkdir build && cd build # создать директорию сборки и перейти в нее
cmake .. -G "MinGW Makefiles" # сгенерировать файлы сборки
cmake --build . # выполнить сборку
```
## Запуск
Программу необходимо запускать из корневой директории проекта, иначе файл конфигурации `settings.json` не будет найден.

Пример запуска после сборки:
```bash
cd .. # перейти в корневую директорию проекта
build/bin/yuki-voice-assistant
```
## Зависимости для Linux
* Для открытия веб-сайтов используется `xdg-open`, если утилита отсутствует или работает некорректно, сайты могут не открываться.
* Для взаимодействия с медиа используется `playerctl`, если утилита отсутствует или работает некорректно, взаимодействие с медиа может не работать.
## Архитектура проекта
`RequestType` - перечисление поддерживаемых типов запросов:

0. SCENARIO - выполняет сценарий, то есть последовательность запросов с заранее заданными аргументами одной командой. Например, команда `включи музыку` может открыть медиаплеер(например, `spotify`) и переключить состояние воспроизведения медиа(`TOGGLE_MEDIA`). Не принимает аргументов, задает значение для `Request::scenario_id`.
1. OPEN - открывает программу или веб-сайт. Аргумент: имя сайта или программы, указанное в `applications.json` или `websites.json`.
	* Сначала проверяется точное совпадение аргумента со списком приложений, затем - со списком сайтов.
	* Если точного совпадения не найдено, выполняется поиск по всем известным приложениям, затем по сайтам, с оценкой точности совпадения
	* По умолчанию выбирается лучший вариант при совпадении более 70%. Порог можно изменить через константу `ACCURANCY_PERCENT` в `context-graph.h`.
2. WEB_SEARCH - поиск в интернете. Аргумент: строка поискового запроса. Неподдерживаемые символы в кодируются в HEX, после чего закодированная строка открывается через google.
3. SHUTDOWN - выключает компьютер. Аргументы не принимает.
4. STOP - завершает работу программы. Перед завершением ожидается обработка и выполнение всех запросов, поставленных в очередь.
5. TOGGLE_MEDIA - переключает состояние медиа между `вкл` и `выкл`.
6. PREVIOUS_MEDIA - включает предыдущее медиа (как правило в медиаплеерах, если трек уже воспроизводится несколько секунд, попытка включить предыдущий трек просто отмотает текущую композицию в начало).
7. NEXT_MEDIA - включает следующее медиа.
8. UNKNOWN - неизвестный тип запроса, не выполняется.

`Request` - структура, представляющая запрос. Содержит:
* `RequestType`.
* Строку с аргументом (если есть).
* Id сценария.

`Worker` - класс, выполняющий задачи типа `std::function<void()>` в отдельном потоке. Задачи ставятся в очередь и выполняются последовательно.

`RecognizeModel` - обертка над библиотекой распознавания речи. Конструктор принимает `const char*`(путь к модели), а аудиоданные подаются на обработку через `RecognizeAudio`. Использование этого класса позволяет без лишних проблем заменить используемую библиотеку для распознавания речи, изменив содержимое класса, но оставив старый набор аргументов в конструкторе и `RecognizeAudio`, если новая библиотека принимает аудиосемплы типа `int16_t`.

`Node` - вершина графа контекста. Содержит:
* `RequestType`
* Признак наличия аргумента (булева переменная)
* Id сценария.

Если `RequestType` имеет тип `UNKNOWN`, узел считается промежуточным.

`ContextGraph` - граф контекста. Вершины графа - слова, получаемые при разбиении фразы.

Методы:
* `AddPhrase` - добавление новой фразы в граф.
* `TrainGraph` - заполнение графа из csv файла (см. раздел `Конфигурационные файлы`).
* `AddOftenMistakes` - добавление частых ошибок при распознавании речи (ошибочные слова будут заменяться на корректные).
* `ParsePhrase` - определение типа команды и извлечение аргумента, если он должен быть.

`VoiceAssistantInit` - структура для удобной инициализации `VoiceAssistant`.

`VoiceAssistant` - класс голосового ассистента. В конструкторе принимает `VoiceAssistantInit`, конструирует объект `RecognizeModel` и `ContextGraph` данными, полученными из `VoiceAssistantInit`.

Основные методы:
	* `MiniAudioCallback` - callback из miniaudio, передающий данные в `ProcessAudio`, чтобы не блокировать поток miniaudio.
	* `ProcessAudio` - проверяет, превышае ли уровень громкости порог (по умолчанию 2000. Изменяется через `VOL_LIMIT`). Если порог превышен, речь записывается в буфер и затем в отдельном потоке передается в `RecognizeModel`. Результат распознавания отправляется в `ContextGraph`, после чего запрос выполняется.
## Конфигурационные файлы
Для работы программы необходимы `settings.json` и файл построения графа контекста, без них программа не сможет выполнять свои функции, остальные файлы рекомендованы для полноценной работы программы, но их отсутствие не препятствует конструированию всех нужных объектов. 
Важно:
* Имя и расположение `settings.json` нельзя менять, иначе программа не сможет найти его.
* Имя и расположение остальных файлов можно менять, если указать новые пути в `settings.json`.

`settings.json` - файл настроек, содержит пути к остальным конфигурационным файлам.
Содержит следующие поля:
* `model` - путь к модели распознавания vosk.
* `ctx_file` - путь к csv файлу для построения ContextGraph.
* `often_mistakes` - путь к csv файлу с частыми ошибками при распознавании речи.
* `websites` - путь к json файлу со списком поддерживаемых веб-сайтов.
* `applications` - путь к json файлу со списком поддерживаемых программ.
* `scenarios` - путь к json файлу со сценариями.

`context_training.csv` - файл для построения графа контекста, содержит 3 столбца:
* `command_id` - Id команды (см. `RequestType`).
* `phrase` - фраза для распознавания.
* `has_arg` - `arg`(принимает аргумент) или `none`(не принимает).

Фраза не должна содержать знаки пунктуации или специальные символы, иначе тип команды может быть определен неверно.

`often_mistakes.csv` - файл с частыми ошибками при распознавании речи.

Содержит 2 столбца:
* `mistake` - ошибочно распознанное слово.
* `correct` - правильный вариант.

При добавлении новой пары удостоверьтесь, что ошибочное слово не является подстрокой какой либо команды или другого ошибочного слова, иначе это приведет к ошибкам определения типа команды.

Например, есть ветки графа контекста, ведущие к разным типам команд и начинающиеся с `включи` и `переключи`, если добавить в файл частых ошибок пару `ключи`->`включи`, то программа не сможет распознать команды по ветке `переключи`, если слово `переключи` будет распознанно неточно(например `переключить`, `переключите`).

`applications.json` - файл со списком поддерживаемых программ.
* Ключи - названия программ в голосовом ассистенте, по которым будет происходить поиск совпадения с аргументом из запроса на открытие приложений или веб-сайтов.
* Значения - путь к исполняемому файлу программы.

Важно указывать именно путь к программе, а не команду ее запуска или путь вместе с аргументами, например: на линукс установлен клиент spotify через flatpak и запуск производится через `flatpak run com.spotify.Client`, если указать эту команду в значении для ключа `spotify`, то программа не сможет открыться, т.к. это не путь к файлу. Чтобы в такой ситуации добавить поддержку spotify, нужно создать bash скрипт, запускающий spotify, и указывать путь к этому скрипту, пример такого скрипта:
```bash
#!/bin/bash
flatpak run com.spotify.Client
```
Если директория с бинарником искомой программы находится в системной PATH, то можно просто указать название бинарника.
Пример оформления `applications.json` на windows:
```json
{
	"telegram": "C:\\Users\\User\\AppData\\Roaming\\Telegram Desktop\\Telegram.exe", // абсолютный путь к exe-шнику телеграма
	"браузер": "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe" // абсолютный путь к exe-шнику Edge
}
```

`websites.json` - файл со списком поддерживаемых веб-сайтов.
* Ключи - названия сайтов в голосовом ассистенте, по которым будет происходить поиск совпадения с аргументом из запроса на открытие приложений или веб-сайтов.
* Значения - url сайта.

`scenarios.json` - файл со сценариями.
* Ключи - команда для выполнения сценария.
* Значения - массив с запросами.
Каждый запрос представляется в виде массива, 1-й элемент которого - тип запроса, 2-й - аргумент, который этот запрос принимает. Если запрос какого то типа не принимает аргумент, то можно оставить массив запроса с 1 элементом, т.к. аргумент не будет проверяться. Например:
```json
{
	"включи музыку": [[1, "spotify"],
							[5]]
}
```
`включи музыку` - команда запуска данного сценария. Сценарий имеет 2 запроса: открыть `spotify` и переключить состояние медиа. Так как переключение состояния медиа не принимает аргумента, то указан только id команды.
## Логирование
Логи выводятся в stdout в формате jsonl. Json объект лога имеет 3 поля:
* `timestamp` - временная метка формата `<год>-<месяц>-<число>T<час>:<минута>:<секунда>.<миллисекунда>`.
* `data` - информация о запросе, может иметь следующие поля:
	* `type` - тип лога: ошибка, предупреждение, информация и т.д.
	* `request_type` - тип запроса.
	* `request_arg` - аргумент запроса.
	* `scenario_id` - порядковый номер сценария в `scenarios.json` (нумерация с 0).
	* `exception` - информация об исключении.
	* `where` - где произошла ошибка.
* `message` - сообщение с дополнительной информацией.

Сообщение `Program loaded successfully` сигнализирует о готовности ассистента к работе.

Сообщение `Program was completed successfully` свидетельствует об успешном завершении программы без ошибок и исключений.
## Добавление нового типа команд
Программа разработана с возможностью удобного расширения списка команд. Чтобы добавить новый тип:
1. Добавьте новый элемент в конец перечисления `RequestType`(если добавить в начало или в середину, то `context_training.csv` станет невалидным).
2. Добавить обработку нового типа в `GetRequestTypeString` для логирования.
3. Реализовать функции для выполнения новой команды в `common.h` и `common.cpp`.
4. Добавить обработку нового типа в `VoiceAssistant::ExecRequest`.
5. Добавить фразу для нового типа команд в `context_training.csv`.

Например, мы хотим добавить команду `привет`, которая будет выводить в лог `GREETINGS`:
1. Обновляем `RequestType` и `GetRequestTypeString`:
```cpp
enum class RequestType {
	...
	NEXT_MEDIA,
	GREETINGS, // новый элемент перечисления
	UNKNOWN = INT_MAX
};

inline std::string GetRequestTypeString(RequestType type) {
	std::string res;
	switch (type) {
	...
	case RequestType::NEXT_MEDIA:
		res = "next media";
		break;
	case RequestType::GREETINGS: // обработка нового типа для логов
		res = "greetings";
		break;
	case RequestType::UNKNOWN:
		res = "unknown";
		break;
	}

	return res;
}
```
2. добавляем в `common.h` и `common.cpp` функции для новой команды:
`common.h`:
```cpp
#pragma once
...
void NextMedia();
void Greetings(); // новая функция
```
`common.cpp`:
```cpp
#include "common.h"
#include "logging.h"
#include <boost/log/utility/manipulators/add_value.hpp>
...
void Greetings() {
	BOOST_LOG_TRIVIAL(info) << "GREETINGS"; // выводим в лог нужное сообщение
}
```
3. Добавляем обработку новой команды в `VoiceAssistant::ExecRequest`:
```cpp
void VoiceAssistant::ExecRequest(const Request& req) const {
	switch (req.type) {
	case RequestType::NEXT_MEDIA:
		NextMedia();
		break;
	case RequestType::GREETINGS:
		Greetings();
		break;
	case RequestType::UNKNOWN:
		return;
	}
}
```
4. Добавляем в `context_training.csv` фразы для новой команды:
```
command_id,phrase,has_arg
...
7,включи следующее медиа,none
8,приветствие,none
```
Команда с id 8 будет активироваться по фразе "приветствие" и не будет принимать аргументов.
